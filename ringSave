/* function createWarpHole(position) {
        // Visual
        const ringGeometry = new THREE.TorusGeometry(0.5, 0.15, 16, 32);
        const ringMaterial = new THREE.MeshNormalMaterial({});
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.position.copy(position);
        ring.rotation.x = Math.PI / 2;
        scene.add(ring);

        // Partículas para efeito
        const particles = new THREE.BufferGeometry();
        const particleCount = 100;
        const posArray = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 1.5;
        }
        particles.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particleMaterial = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.1,
            transparent: true,
            opacity: 0.8
        });
        const particleSystem = new THREE.Points(particles, particleMaterial);
        particleSystem.position.copy(position);
        scene.add(particleSystem);

        // Física - Corpo de colisão
        const warpShape = new CANNON.Sphere(0.5);
        const warpBody = new CANNON.Body({
            mass: 0,
            material: objectMaterial,
            shape: warpShape,
            isTrigger: true,
            position: new CANNON.Vec3(position.x, position.y, position.z)
        });
        warpBody.userData = { isWarpHole: true };
        world.addBody(warpBody);

        return {
            mesh: ring,
            particles: particleSystem,
            body: warpBody
        };
    }

    // Crie o buraco em algum lugar do tabuleiro
    const warpHole = createWarpHole(new THREE.Vector3(-0.75, 0.5, -11)); */